using System;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Runtime.Loader;

namespace FlowerBI.Tools
{
    class Program
    {
        static int Main(string[] args)
        {
            if (args.Length == 4 && args[0] == "ts")
            {
                return GenerateTSFromReflection(args[1], args[2], args[3]);
            }

            if (args.Length == 3 && args[0] == "ts")
            {
                return GenerateTSFromYaml(args[1], args[2]);
            }
            
            if (args.Length == 4 && args[0] == "cs")
            {
                return GenerateCSFromYaml(args[1], args[2], args[3]);            
            }

            Console.WriteLine("Usage:");
            Console.WriteLine();
            Console.WriteLine("Generate Typescript from a yaml declaration:");
            Console.WriteLine();
            Console.WriteLine("        ts <yaml-file> <ts-file>");
            Console.WriteLine();
            Console.WriteLine("Generate C# from a yaml declaration:");
            Console.WriteLine();
            Console.WriteLine("        cs <yaml-file> <cs-file> <cs-namespace>");
            Console.WriteLine();
            Console.WriteLine("Generate Typescript from an assembly:");
            Console.WriteLine();
            Console.WriteLine("        ts <dll> <schema-class> <ts-file>");
            Console.WriteLine();
            return -1;
        }

        // What about nullable?
        static DataType DataTypeFromClr(Type clrType) => 
            clrType == typeof(bool) ? DataType.Bool :
            clrType == typeof(byte) ? DataType.Byte :
            clrType == typeof(short) ? DataType.Short :
            clrType == typeof(int) ? DataType.Int :
            clrType == typeof(long) ? DataType.Long :
            clrType == typeof(float) ? DataType.Float :
            clrType == typeof(double) ? DataType.Double :
            clrType == typeof(decimal) ? DataType.Decimal :
            clrType == typeof(string) ? DataType.String :
            clrType == typeof(DateTime) ? DataType.DateTime :
            throw new InvalidOperationException($"Unsupported data type: {clrType}");
        
        static string CSColumnType(DataType dataType) => dataType switch
        {
            DataType.Bool => "bool",
            DataType.Byte => "byte",
            DataType.Short => "short",
            DataType.Int => "int",
            DataType.Long => "long",
            DataType.Float => "float",
            DataType.Double => "double",
            DataType.Decimal => "decimal",
            DataType.String => "string",
            DataType.DateTime => "DateTime",
            _ => throw new InvalidOperationException($"Unsupported data type: {dataType}")
        };

        static string TSColumnType(DataType dataType)
        {
            var jsType = dataType switch
            {
                DataType.Bool => "boolean",
                DataType.String => "string",
                DataType.DateTime => "Date",
                _ => "number"
            };
            return jsType == "number" ? "NumericQueryColumn" : $"QueryColumn<{jsType}>";
        }

        static int GenerateTSFromYaml(string yamlFile, string tsFile)
        {
            var schema = ResolvedSchema.Resolve(File.ReadAllText(yamlFile));

            using var writer = new StreamWriter(tsFile);

            Console.WriteLine($"Saving to file {tsFile}");

            writer.WriteLine(@"import { QueryColumn, NumericQueryColumn } from ""flowerbi"";");
            writer.WriteLine();
            writer.WriteLine("// Important: this file is auto-generated by flowerbi.");
            writer.WriteLine();

            foreach (var table in schema.Tables)
            {
                Console.WriteLine($"Exporting table {table.Name}");
                writer.WriteLine($"export const {table.Name} = {{");

                foreach (var column in new[] { table.IdColumn }.Concat(table.Columns))
                {
                    var tsType = TSColumnType(column.DataType);
                    writer.WriteLine(@$"    {column.Name}: new {tsType}(""{table.Name}.{column.Name}""),");
                }

                writer.WriteLine("};");
                writer.WriteLine();
            }
            
            writer.WriteIndentedLine($"export const {schema.Name} = {{");
            foreach (var table in schema.Tables)
            {
                writer.WriteIndentedLine(@$"{table.Name},", 1);
            }
            writer.WriteIndentedLine("};");

            writer.Flush();
            Console.WriteLine("Done.");
            return 0;
        }

        static int GenerateCSFromYaml(string yamlFile, string csFile, string csNamespace)
        {
            var schema = ResolvedSchema.Resolve(File.ReadAllText(yamlFile));            

            using var writer = new StreamWriter(csFile);

            Console.WriteLine($"Saving to file {csFile}");

            writer.WriteLine($"namespace {csNamespace};");
            writer.WriteLine("using System;");
            writer.WriteLine("using FlowerBI;");
            writer.WriteLine();
            writer.WriteLine();
            writer.WriteLine("// Important: this file is auto-generated by flowerbi.");
            writer.WriteLine();
            
            writer.WriteLine($"[DbSchema(\"{schema.NameInDb}\")]");
            writer.WriteLine($"public static class {schema.Name}");
            writer.WriteLine("{");

            foreach (var table in schema.Tables)
            {
                Console.WriteLine($"Exporting table {table.Name}");

                writer.WriteLine($"    [DbTable(\"{table.NameInDb}\")]");
                writer.WriteLine($"    public static class {table.Name}");
                writer.WriteLine("    {");

                string ExtendColumn(ResolvedColumn c) => c.Extends == null 
                    ? string.Empty 
                    : $", extends: {c.Extends.Table.Name}.{c.Extends.Name}";

                var idType = CSColumnType(table.IdColumn.DataType);
                writer.WriteLine($"        public static readonly PrimaryKey<{idType}> {table.IdColumn.Name} = new PrimaryKey<{idType}>(\"{table.IdColumn.Name}\"{ExtendColumn(table.IdColumn)});");

                foreach (var column in table.Columns)
                {
                    var columnType = CSColumnType(column.DataType);

                    if (column.Target != null)
                    {
                        writer.WriteLine($"        public static readonly ForeignKey<{columnType}> {column.Name} = new ForeignKey<{columnType}>(\"{column.Name}\", {column.Target.Table.Name}.{column.Target.Name}{ExtendColumn(column)});");
                    }
                    else
                    {
                        writer.WriteLine($"        public static readonly Column<{columnType}> {column.Name} = new Column<{columnType}>(\"{column.Name}\"{ExtendColumn(column)});");
                    }
                }    

                writer.WriteLine("    }");
            }

            writer.WriteLine("}");
            
            writer.Flush();
            Console.WriteLine("Done.");

            return 0;
        }

        static int GenerateTSFromReflection(string path, string schemaClass, string outputFile)
        {
            path = Path.GetFullPath(path);

            Console.WriteLine($"Reading assembly {path}");

            var schemaType = AssemblyLoadContext.Default.LoadFromAssemblyPath(path).GetType(schemaClass);
            if (schemaType == null)
            {
                Console.WriteLine($"No such type {schemaType} in assembly");
                return -1;
            }

            Console.WriteLine($"Reading type {schemaType.FullName}");

            using var writer = new StreamWriter(outputFile);

            Console.WriteLine($"Saving to file {outputFile}");

            writer.WriteLine(@"import { QueryColumn, NumericQueryColumn } from ""flowerbi"";");
            writer.WriteLine();
            writer.WriteLine("// Important: this file is auto-generated by flowerbi.");
            writer.WriteLine();

            static string MapColumnType(Type clrType) => TSColumnType(DataTypeFromClr(clrType));
            
            var tables = new Schema(schemaType).Tables.ToImmutableArray();
            foreach (var table in tables)
            {
                Console.WriteLine($"Exporting table {table.RefName}");
                writer.WriteLine($"export const {table.RefName} = {{");

                foreach (var column in table.Columns)
                {
                    var tsType = MapColumnType(column.ClrType);
                    writer.WriteLine(@$"    {column.RefName}: new {tsType}(""{table.RefName}.{column.RefName}""),");
                }

                writer.WriteLine("};");
                writer.WriteLine();
            }
            
            writer.WriteIndentedLine($"export const {schemaType.Name} = {{");
            foreach (var table in tables)        
            {
                writer.WriteIndentedLine(@$"{table.RefName},", 1);
            }
            writer.WriteIndentedLine("};");

            writer.Flush();
            Console.WriteLine("Done.");

            return 0;
        }
    }
}
